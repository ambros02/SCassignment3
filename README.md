<h1>Virtual Machine and Debugger Documentation</h1>

<h2>1. Unit Testing</h2>

<h3>Implementation</h3>

<h4>Overview</h4>
<p>The virtual Machine and the assembler are tested individually, however since we are allowed to assume the assembler to be correct we can use the output files of the assembler to test the virtual machine. Usually in unit testing we would like the tests to be completly independent from one another. In this case this would mean writing the mx files for the virtual machine tests by hand.</p>

<h4>Structure</h4>
<p>Root directory is exercise_1, in the vm_tests directory are all files with the tests. In the test_files directory are all files used and generated by the tests.</p>

<h4>Assembler</h4>
<p>To test the assember several .as files are created and put into the test_files directory.These files consist of simple operations using the operations for the virtual machine. The desired output of the assembler is calculated by hand and saved in a dictionary. Then the assembler is used to assemble the operations from the file into binary format. The tests assert if the actual output the assembler gave matches the desired output calculated by hand. For simplicity and scalability fixtures are used to access the informations for a given file, aswell as a helper function assemble_basis which assembles the code.</p>

<h4>Virtual Machine</h4>
<p>To test the virtual machine the .as file from the assembler test is passed through the assembler and stored as an mx file. The virtual machine can then use this file for testing and later call the remove_file function to cleanup. Further there is the helper function fetch_instructions and execute_vm which simulate the main function of the vm.py file. All what is left to do is use the existing files and test if the vm handles the instructions correctly.</p>

<h4>Integration Testing</h4>
<p>The Integration tests are used to verify the correctness of the helper functions such as the show or main function. To achieve this for vm and assembler an inegration .as respectively .mx file is created and the program is run as if it was called.</p>


<h4>Coverage</h4>
<p>The tests have a total branch coverage of 98% missing </p>

<h3>Use</h3>

<h4>Run Tests<h4>
<p>To run all tests navigate to the exercise_1 directory and use the command: <br>
-pytest<br></p>

<h4>Test covergage</h4>
<p>To gain a test coverage report navigate to the exercise_1 directory and use the command:<br>
-pytest --cov --cov-branch --cov-report=html.'name'<br>
to get a folder containing an index.html which will display the report info</p>

<h2>2. Disassembler</h2>

<h3>Implementation</h3>

<h3>Use</h3>

<h3>Testing</h3>

<h2>3. New features and Problems - Assembler</h2>

<h3>3.1 Increment and Decrement</h3>

<h3>3.2 Swap Values</h3>

<h3>3.3 Reverse array in place</h3>

<h2>4. New features - Debugger</h2>

<h3>4.1 Show Memory Range</h3>

<h3>4.2 Breakpoint Addresses</h3>

<h3>4.3 Command Completion</h3>

<h3>4.4 Watchpoints</h3>