<h1>Virtual Machine and Debugger Documentation</h1>

<h2>1. Unit Testing</h2>

<h3>Implementation</h3>

<h4>Overview</h4>
<p>The virtual Machine and the assembler are tested individually, however since we are allowed to assume the assembler to be correct we can use the output files of the assembler to test the virtual machine. Usually in unit testing we would like the tests to be completly independent from factors which are not being tested. In this case this would mean writing the mx files for the virtual machine tests by hand.</p>

<h4>Structure</h4>
<p>Root directory is exercise_1, in the vm_tests directory are all files with the tests. In the test_files directory are all files used and generated by the tests.</p>

<h4>Assembler</h4>
<p>To test the assember several .as files are created and put into the test_files directory.These files consist of simple operations using the operations for the virtual machine. The desired output of the assembler is calculated by hand and saved in a dictionary. Then the assembler is used to assemble the operations from the file into binary format. The tests assert if the actual output the assembler gave matches the desired output calculated by hand. For simplicity and scalability fixtures are used to access the informations for a given file, aswell as a helper function assemble_basis which assembles the code.</p>

<h4>Virtual Machine</h4>
<p>To test the virtual machine the .as file from the assembler test is passed through the assembler and stored as an mx file. The virtual machine can then use this file for testing and later call the remove_file function to cleanup. Further there is the helper function fetch_instructions and execute_vm which simulate the main function of the vm.py file. All what is left to do is use the existing files and test if the vm handles the instructions correctly.</p>

<h4>Integration Testing</h4>
<p>The Integration tests are used to verify the correctness of the helper functions such as the show or main function. To achieve this for vm and assembler an inegration .as respectively .mx file is created and the program is run as if it was called. This might not seem to do much now, however if we extend the program and say there could be extra data in an .as file which is being handled by the assembler this can come in handy.</p>


<h4>Coverage</h4>
<p>The tests have a total branch coverage of 98% missing </p>

<h3>Use</h3>

<h4>Run Tests<h4>
<p>To run all tests navigate to the exercise_1 directory and use the command: <br>
>>>pytest<br></p>

<h4>Test covergage</h4>
<p>To gain a test coverage report navigate to the exercise_1 directory and use the command:<br>
>>>pytest --cov --cov-branch --cov-report=html.'name'<br>
to get a folder containing an index.html which will display the report info</p>

<h2>2. Disassembler</h2>

<h3>Implementation</h3>

<h3>Use</h3>

<h3>Testing</h3>

<h2>3. New features and Problems - Assembler</h2>

<h3>3.1 Increment and Decrement</h3>

<h3>3.2 Swap Values</h3>

<h3>3.3 Reverse array in place</h3>

<h2>4. New features - Debugger</h2>

<h3>4.1 Show Memory Range</h3>

<h3>4.2 Breakpoint Addresses</h3>
<p>This Implementation was not only made for breakpoint addresses but more general for all commands. Just specify the addresses after the command, sepperated by single whitespaces e.g. break 2 3 will create a breakpoint at address 2 and 3. It uses a loop to run the command once for each specified address. Also note it is in the programmers responsibility to use correct addresses e.g. in the range of the program.if no address is specified, the current address will be used.</p>

<h3>4.3 Command Completion</h3>
<p>From the input of the user all handlers that start with the specified string are fetched. If there is only one handle it will execute. If there are multiple options a list of the possible matches is returned and the user may try again. This however implies that if a file is run all the commands must be uniquely identifying a handler or the program will crash.</p>

<h3>4.4 Watchpoints</h3>